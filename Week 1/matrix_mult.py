import numpy as np
import typing as tp


A = np.array([[1, 2, 3], 
              [4, 5, 6], 
              [7, 8, 9]])

B = np.array([[1, 2, 3], 
              [4, 5, 6], 
              [7, 8, 9]])
print(A)
print(np.array(B.transpose))
print(np.array(np.outer(A, B.T)))


def matrix_multiplication(A: np.ndarray, B: np.ndarray) -> np.ndarray:
    # Запоминаем размерности: мы умножаем матрицу размера nxm на матрицу размера mxk.
    n, m, k = A.shape[0], A.shape[1], B.shape[1]
    # Считаем внешнее произведение матриц. Заметим, что тогда получается матрица размера (nm)x(mk), таким образом,
    # матрица разбивает на nk подматриц размера mxm.
    C = np.array(np.outer(A, B.T))
    # Давайте так и разобьем их на подматрицы. К сожалению, сразу сделать numpy.reshape не выдаст желаемого результата
    # из-за "сканирования по строчкам". Сначала разобьем по вертикали на k столбцов нашу матрицу.
    D = np.array(np.hsplit(C, k))
    # Теперь можно сделать уже нормальный reshape, и все будет как надо. Мы получили матрицу nxk, элементами которой являются
    # матрицы размера mxm. Единственное, она получилась транспонированной. Пока что так даже удобнее, поскольку транспонировать
    # ее в таком виде будет криво (какие-то сложности из-за излишней многомерности).
    E = D.reshape(k, n, m, m)
    # Ну давайте посчитаем след каждой такой матрицы размера mxm. Совершенно случайно он оказывается элементом искомого
    # произведения матриц (именно это было замечено при выполнении numpy.outer). Таким образом, все хорошо, разве что
    # не забудем все же транспонировать матрицу.
    # P. S. Заметим, что каждой операцией мы получаем матрицу, а потом только один раз ее используем. Так что при большом
    # желании это все упихивается в одну никому не понятную строчку:
    # np.trace(np.array(np.hsplit(np.array(np.outer(A, B.T)), B.shape[1])).
    #                            reshape(B.shape[1], A.shape[0], A.shape[1], A.shape[1]), axis1=2, axis2=3).T
    # Может, так будет быстрее.
    return np.trace(E, axis1=2, axis2=3).T